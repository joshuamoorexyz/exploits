# exploits


Vulnerabilities & Exploits
WordPress version 4.2



Exploit 1

Title: WordPress <= 4.2 - Unauthenticated Stored Cross-Site Scripting (XSS)

     Fixed in: 4.2.1

     References:
     https://wpscan.com/vulnerabilities/7945
     https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3440
     https://www.exploit-db.com/exploits/36844/
     http://klikki.fi/adv/wordpress2.html
     https://packetstormsecurity.com/files/131644/

Description from exploit-db:
This vulnerability was present 
Cross-site scripting (XSS) vulnerability in wp-includes/wp-db.php in WordPress before 4.2.1 allows remote attackers to inject arbitrary web script or HTML via a long comment that is improperly stored because of limitations on the MySQL TEXT data type.

Confirmed vulnerable: WordPress 4.2, 4.1.2, 4.1.1, 3.9.3.

an example of this is:
<a title='x onmouseover=alert(unescape(/hello%20world/.source)) style=position:absolute;left:0;top:0;width:5000px;height:5000px AAAAAAAAAAAA...[64 kb]..AAA'></a>
from the site : http://klikki.fi/adv/wordpress2.html
A great write up of this is posted at the url:  https://packetstormsecurity.com/files/131644/
The solution to fix this is to disable comments

Exploit 2


Title: WordPress <= 4.3 - User List Table Cross-Site Scripting (XSS)

     Fixed in: 4.2.5

     References:
     https://wpscan.com/vulnerabilities/8187
     https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7989
     https://wordpress.org/news/2015/09/wordpress-4-3-1/
     https://github.com/WordPress/WordPress/commit/f91a5fd10ea7245e5b41e288624819a37adf290a


description from cve.mitre.org:
Cross-site scripting (XSS) vulnerability in the user list table in WordPress before 4.3.1 allows remote authenticated users to inject arbitrary web script or HTML via a crafted e-mail address, a different vulnerability than CVE-2015-5714.

CVE 2015-7989


An example of this vulnerability is: 

* @param WP_User $user The current WP_User object.




*/


public function column_email( $user ) {


echo "<a href='mailto:$user->user_email'>$user->user_email</a>";


echo "<a href='" . esc_url( "mailto:$user->user_email" ) . "'>$user->user_email</a>";


}





/**


Exploit 3


 Title: WordPress 3.5-4.7.1 - WP_Query SQL Injection

     Fixed in: 4.2.12

    References:
    https://wpscan.com/vulnerabilities/8730
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5611
    https://wordpress.org/news/2017/01/wordpress-4-7-2-security-release/
    https://github.com/WordPress/WordPress/commit/85384297a60900004e27e417eac56d24267054cb




.


Cve 2017 5611

SQL injection vulnerability in wp-includes/class-wp-query.php in WP_Query in WordPress before 4.7.2 allows remote attackers to execute arbitrary SQL commands by leveraging the presence of an affected plugin or theme that mishandles a crafted post type name.




From github.com/wordpress…..

WordPress versions 4.7.1 and earlier are affected by three security issues:
    1. The user interface for assigning taxonomy terms in Press This is shown to users who do not have permissions to use it. Reported by David Herrera of Alley Interactive.
    2. WP_Query is vulnerable to a SQL injection (SQLi) when passing unsafe data. WordPress core is not directly vulnerable to this issue, but we’ve added hardening to prevent plugins and themes from accidentally causing a vulnerability. Reported by Mo Jangda (batmoo).
    3. A cross-site scripting (XSS) vulnerability was discovered in the posts list table. Reported by Ian Dunn of the WordPress Security Team.
    4. An unauthenticated privilege escalation vulnerability was discovered in a REST API endpoint. Reported by Marc-Alexandre Montpas of Sucuri Security. *

if ( empty( $in_search_post_types ) ) {




$where .= ' AND 1=0 ';


} else {


$where .= " AND {$wpdb->posts}.post_type IN ('" . join("', '", $in_search_post_types ) . "')";


$where .= " AND {$wpdb->posts}.post_type IN ('" . join( "', '", array_map( 'esc_sql', $in_search_post_types ) ) . "')";


}


} elseif ( !empty( $post_type ) && is_array( $post_type ) ) {


$where .= " AND {$wpdb->posts}.post_type IN ('" . join("', '", $post_type) . "')";


$where .= " AND {$wpdb->posts}.post_type IN ('" . join("', '", esc_sql( $post_type ) ) . "')";


} elseif ( ! empty( $post_type ) ) {


$where .= " AND {$wpdb->posts}.post_type = '$post_type'";


$where .= $wpdb->prepare( " AND {$wpdb->posts}.post_type = %s", $post_type );


$post_type_object = get_post_type_object ( $post_type );


} elseif ( $this->is_attachment ) {


$where .= " AND {$wpdb->posts}.post_type = 'attachment'";
